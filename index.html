<!doctype html>
<html lang="en" class="h-full">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Word Search Generator</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="/_sdk/element_sdk.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;500;600;700&amp;display=swap" rel="stylesheet">
  <style>
    body {
      box-sizing: border-box;
    }
    * {
      font-family: 'Fredoka', sans-serif;
    }
    .grid-cell {
      transition: all 0.15s ease;
      user-select: none;
    }
    .grid-cell:hover {
      transform: scale(1.1);
    }
    .grid-cell.selected {
      transform: scale(1.15);
    }
    .grid-cell.found {
      animation: pulse 0.3s ease;
    }
    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.2); }
    }
    .word-item.found {
      text-decoration: line-through;
      opacity: 0.5;
    }
    .sparkle {
      animation: sparkle 0.6s ease-out forwards;
    }
    @keyframes sparkle {
      0% { transform: scale(0) rotate(0deg); opacity: 1; }
      100% { transform: scale(1.5) rotate(180deg); opacity: 0; }
    }
    @media print {
      body {
        background: white !important;
        color: black !important;
      }
      .no-print {
        display: none !important;
      }
      #puzzle-view {
        display: flex !important;
      }
      #generator-view {
        display: none !important;
      }
      #grid-container {
        background: white !important;
        border: 2px solid black !important;
        page-break-inside: avoid;
      }
      .grid-cell {
        background: white !important;
        color: black !important;
        border: 1px solid black !important;
      }
      #word-list {
        columns: 2;
        column-gap: 2rem;
      }
      .word-item {
        background: white !important;
        color: black !important;
        border: 1px solid black !important;
      }
    }
  </style>
  <style>@view-transition { navigation: auto; }</style>
  <script src="/_sdk/data_sdk.js" type="text/javascript"></script>
 </head>
 <body class="h-full">
  <div id="app" class="h-full w-full overflow-auto" style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);"><!-- Generator View -->
   <div id="generator-view" class="min-h-full p-6 flex flex-col items-center">
    <div class="w-full max-w-md">
     <h1 id="main-title" class="text-4xl font-bold text-center mb-2" style="color: #e94560;">Word Search</h1>
     <p class="text-center mb-8" style="color: #a2d2ff;">Create your custom puzzle</p>
     <div class="rounded-2xl p-6 mb-6" style="background: rgba(255,255,255,0.05); backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.1);"><label class="block mb-2 font-medium" style="color: #a2d2ff;">Enter Words (one per line)</label> <textarea id="words-input" rows="6" placeholder="APPLE
BANANA
CHERRY
GRAPE
ORANGE" class="w-full rounded-xl p-4 text-lg resize-none focus:outline-none focus:ring-2" style="background: rgba(255,255,255,0.08); color: #fff; border: 1px solid rgba(255,255,255,0.15); caret-color: #e94560;"></textarea>
      <p class="text-sm mt-2" style="color: rgba(162,210,255,0.6);">Max 10 words, letters only</p>
     </div>
     <div class="rounded-2xl p-6 mb-6" style="background: rgba(255,255,255,0.05); backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.1);"><label class="block mb-3 font-medium" style="color: #a2d2ff;">Grid Size</label>
      <div class="flex gap-3"><button class="size-btn flex-1 py-3 rounded-xl font-semibold transition-all" data-size="10" style="background: #e94560; color: #fff;">10√ó10</button> <button class="size-btn flex-1 py-3 rounded-xl font-semibold transition-all" data-size="12" style="background: rgba(255,255,255,0.1); color: #a2d2ff;">12√ó12</button> <button class="size-btn flex-1 py-3 rounded-xl font-semibold transition-all" data-size="15" style="background: rgba(255,255,255,0.1); color: #a2d2ff;">15√ó15</button>
      </div>
     </div>
     <div class="rounded-2xl p-6 mb-6 flex items-center gap-3" style="background: rgba(255,255,255,0.05); backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.1);"><input type="checkbox" id="lowercase-toggle" class="w-5 h-5 rounded cursor-pointer" style="accent-color: #e94560;"> <label for="lowercase-toggle" class="font-medium cursor-pointer" style="color: #a2d2ff;">Use lowercase letters</label>
     </div><button id="generate-btn" class="w-full py-4 rounded-xl font-bold text-xl transition-all hover:scale-105 active:scale-95" style="background: linear-gradient(135deg, #e94560 0%, #ff6b6b 100%); color: #fff; box-shadow: 0 4px 20px rgba(233,69,96,0.4);"> ‚ú® Generate Puzzle </button>
     <div id="error-msg" class="mt-4 p-4 rounded-xl text-center hidden" style="background: rgba(233,69,96,0.2); color: #ff6b6b;"></div>
    </div>
   </div><!-- Puzzle View -->
   <div id="puzzle-view" class="min-h-full p-4 flex flex-col items-center hidden">
    <div class="w-full max-w-2xl">
     <div class="flex items-center justify-between mb-4 no-print"><button id="back-btn" class="px-4 py-2 rounded-xl font-medium transition-all hover:scale-105" style="background: rgba(255,255,255,0.1); color: #a2d2ff;"> ‚Üê Back </button>
      <h2 id="puzzle-title" class="text-2xl font-bold" style="color: #e94560;">Word Search</h2>
      <div class="flex gap-2"><button id="print-btn" class="px-4 py-2 rounded-xl font-medium transition-all hover:scale-105" style="background: rgba(255,255,255,0.1); color: #a2d2ff;"> üñ®Ô∏è Print </button> <button id="new-puzzle-btn" class="px-4 py-2 rounded-xl font-medium transition-all hover:scale-105" style="background: rgba(255,255,255,0.1); color: #a2d2ff;"> üîÑ New </button>
      </div>
     </div>
     <div id="grid-container" class="rounded-2xl p-4 mb-4 overflow-x-auto" style="background: rgba(255,255,255,0.05); backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.1);">
      <div id="puzzle-grid" class="grid gap-1 mx-auto" style="width: fit-content;"></div>
     </div>
     <div class="rounded-2xl p-4" style="background: rgba(255,255,255,0.05); backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.1);">
      <div class="flex items-center justify-between mb-3">
       <h3 class="font-semibold" style="color: #a2d2ff;">Find These Words</h3><span id="progress" class="text-sm font-medium no-print" style="color: #e94560;">0/0 found</span>
      </div>
      <div id="word-list" class="flex flex-wrap gap-2"></div>
     </div>
     <div id="win-message" class="mt-4 p-6 rounded-2xl text-center hidden no-print" style="background: linear-gradient(135deg, rgba(233,69,96,0.2) 0%, rgba(255,107,107,0.2) 100%); border: 2px solid #e94560;">
      <div class="text-4xl mb-2">
       üéâ
      </div>
      <h3 class="text-2xl font-bold mb-2" style="color: #e94560;">Congratulations!</h3>
      <p style="color: #a2d2ff;">You found all the words!</p>
     </div>
    </div>
   </div>
  </div>
  <script>
    const defaultConfig = {
      puzzle_title: 'Word Search',
      background_color: '#1a1a2e',
      accent_color: '#e94560',
      text_color: '#a2d2ff',
      surface_color: 'rgba(255,255,255,0.05)',
      font_family: 'Fredoka',
      font_size: 16
    };

    let config = { ...defaultConfig };
    let gridSize = 10;
    let grid = [];
    let words = [];
    let wordPositions = {};
    let foundWords = new Set();
    let isSelecting = false;
    let selectedCells = [];
    let startCell = null;
    let useLowercase = false;

    const directions = [
      { dx: 1, dy: 0 },   // right
      { dx: -1, dy: 0 },  // left
      { dx: 0, dy: 1 },   // down
      { dx: 0, dy: -1 },  // up
      { dx: 1, dy: 1 },   // diagonal down-right
      { dx: -1, dy: -1 }, // diagonal up-left
      { dx: 1, dy: -1 },  // diagonal up-right
      { dx: -1, dy: 1 }   // diagonal down-left
    ];

    function onConfigChange(cfg) {
      config = { ...defaultConfig, ...cfg };
      document.getElementById('main-title').textContent = config.puzzle_title;
      document.getElementById('puzzle-title').textContent = config.puzzle_title;
      
      const fontStack = `${config.font_family}, sans-serif`;
      document.querySelectorAll('*').forEach(el => {
        el.style.fontFamily = fontStack;
      });
    }

    function mapToCapabilities(cfg) {
      return {
        recolorables: [
          {
            get: () => cfg.background_color || defaultConfig.background_color,
            set: (v) => { cfg.background_color = v; window.elementSdk.setConfig({ background_color: v }); }
          },
          {
            get: () => cfg.surface_color || defaultConfig.surface_color,
            set: (v) => { cfg.surface_color = v; window.elementSdk.setConfig({ surface_color: v }); }
          },
          {
            get: () => cfg.text_color || defaultConfig.text_color,
            set: (v) => { cfg.text_color = v; window.elementSdk.setConfig({ text_color: v }); }
          },
          {
            get: () => cfg.accent_color || defaultConfig.accent_color,
            set: (v) => { cfg.accent_color = v; window.elementSdk.setConfig({ accent_color: v }); }
          }
        ],
        borderables: [],
        fontEditable: {
          get: () => cfg.font_family || defaultConfig.font_family,
          set: (v) => { cfg.font_family = v; window.elementSdk.setConfig({ font_family: v }); }
        },
        fontSizeable: {
          get: () => cfg.font_size || defaultConfig.font_size,
          set: (v) => { cfg.font_size = v; window.elementSdk.setConfig({ font_size: v }); }
        }
      };
    }

    function mapToEditPanelValues(cfg) {
      return new Map([
        ['puzzle_title', cfg.puzzle_title || defaultConfig.puzzle_title]
      ]);
    }

    // Initialize SDK
    if (window.elementSdk) {
      window.elementSdk.init({
        defaultConfig,
        onConfigChange,
        mapToCapabilities,
        mapToEditPanelValues
      });
    }

    // Size selection
    document.querySelectorAll('.size-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.size-btn').forEach(b => {
          b.style.background = 'rgba(255,255,255,0.1)';
          b.style.color = '#a2d2ff';
        });
        btn.style.background = '#e94560';
        btn.style.color = '#fff';
        gridSize = parseInt(btn.dataset.size);
      });
    });

    // Lowercase toggle
    document.getElementById('lowercase-toggle').addEventListener('change', (e) => {
      useLowercase = e.target.checked;
    });

    // Generate puzzle
    document.getElementById('generate-btn').addEventListener('click', generatePuzzle);
    document.getElementById('back-btn').addEventListener('click', showGenerator);
    document.getElementById('new-puzzle-btn').addEventListener('click', generatePuzzle);
    document.getElementById('print-btn').addEventListener('click', () => window.print());

    function showGenerator() {
      document.getElementById('generator-view').classList.remove('hidden');
      document.getElementById('puzzle-view').classList.add('hidden');
    }

    function showPuzzle() {
      document.getElementById('generator-view').classList.add('hidden');
      document.getElementById('puzzle-view').classList.remove('hidden');
    }

    function showError(msg) {
      const errorEl = document.getElementById('error-msg');
      errorEl.textContent = msg;
      errorEl.classList.remove('hidden');
      setTimeout(() => errorEl.classList.add('hidden'), 3000);
    }

    function generatePuzzle() {
      const input = document.getElementById('words-input').value.trim();
      if (!input) {
        showError('Please enter at least one word');
        return;
      }

      words = input.toUpperCase()
        .split('\n')
        .map(w => w.trim().replace(/[^A-Z]/g, ''))
        .filter(w => w.length >= 2 && w.length <= gridSize)
        .slice(0, 10);

      if (words.length === 0) {
        showError('Please enter valid words (letters only, 2+ characters)');
        return;
      }

      // Sort by length (longest first) for better placement
      words.sort((a, b) => b.length - a.length);

      // Initialize empty grid
      grid = Array(gridSize).fill(null).map(() => Array(gridSize).fill(''));
      wordPositions = {};
      foundWords = new Set();

      // Try to place each word
      let placedWords = [];
      for (const word of words) {
        if (placeWord(word)) {
          placedWords.push(word);
        }
      }

      if (placedWords.length === 0) {
        showError('Could not place any words. Try shorter words or larger grid.');
        return;
      }

      words = placedWords;

      // Fill empty cells with random letters
      const letters = useLowercase ? 'abcdefghijklmnopqrstuvwxyz' : 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
      for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
          if (grid[y][x] === '') {
            grid[y][x] = letters[Math.floor(Math.random() * letters.length)];
          } else if (useLowercase) {
            grid[y][x] = grid[y][x].toLowerCase();
          }
        }
      }

      // Convert words to lowercase if needed
      if (useLowercase) {
        words = words.map(w => w.toLowerCase());
      }

      renderPuzzle();
      showPuzzle();
    }

    function placeWord(word) {
      const shuffledDirs = [...directions].sort(() => Math.random() - 0.5);
      const attempts = 100;

      for (let i = 0; i < attempts; i++) {
        const startX = Math.floor(Math.random() * gridSize);
        const startY = Math.floor(Math.random() * gridSize);

        for (const dir of shuffledDirs) {
          if (canPlaceWord(word, startX, startY, dir)) {
            const positions = [];
            for (let j = 0; j < word.length; j++) {
              const x = startX + j * dir.dx;
              const y = startY + j * dir.dy;
              grid[y][x] = word[j];
              positions.push({ x, y });
            }
            wordPositions[word] = positions;
            return true;
          }
        }
      }
      return false;
    }

    function canPlaceWord(word, startX, startY, dir) {
      for (let i = 0; i < word.length; i++) {
        const x = startX + i * dir.dx;
        const y = startY + i * dir.dy;

        if (x < 0 || x >= gridSize || y < 0 || y >= gridSize) return false;
        if (grid[y][x] !== '' && grid[y][x] !== word[i]) return false;
      }
      return true;
    }

    function renderPuzzle() {
      const puzzleGrid = document.getElementById('puzzle-grid');
      const cellSize = Math.max(24, Math.min(36, Math.floor(280 / gridSize)));
      
      puzzleGrid.style.gridTemplateColumns = `repeat(${gridSize}, ${cellSize}px)`;
      puzzleGrid.innerHTML = '';

      for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
          const cell = document.createElement('div');
          cell.className = 'grid-cell flex items-center justify-center rounded-lg cursor-pointer font-bold';
          cell.style.cssText = `
            width: ${cellSize}px;
            height: ${cellSize}px;
            font-size: ${Math.max(12, cellSize * 0.5)}px;
            background: rgba(255,255,255,0.08);
            color: #fff;
          `;
          cell.textContent = grid[y][x];
          cell.dataset.x = x;
          cell.dataset.y = y;
          
          cell.addEventListener('mousedown', handleMouseDown);
          cell.addEventListener('mouseenter', handleMouseEnter);
          cell.addEventListener('touchstart', handleTouchStart, { passive: false });
          cell.addEventListener('touchmove', handleTouchMove, { passive: false });
          
          puzzleGrid.appendChild(cell);
        }
      }

      document.addEventListener('mouseup', handleMouseUp);
      document.addEventListener('touchend', handleTouchEnd);

      renderWordList();
      updateProgress();
    }

    function renderWordList() {
      const wordList = document.getElementById('word-list');
      wordList.innerHTML = '';

      for (const word of words) {
        const wordEl = document.createElement('span');
        wordEl.className = 'word-item px-3 py-1 rounded-full text-sm font-medium transition-all';
        wordEl.style.cssText = `background: rgba(233,69,96,0.2); color: #e94560;`;
        wordEl.textContent = word;
        wordEl.dataset.word = word;
        if (foundWords.has(word)) {
          wordEl.classList.add('found');
        }
        wordList.appendChild(wordEl);
      }
    }

    function updateProgress() {
      document.getElementById('progress').textContent = `${foundWords.size}/${words.length} found`;
      
      if (foundWords.size === words.length) {
        document.getElementById('win-message').classList.remove('hidden');
      }
    }

    function handleMouseDown(e) {
      isSelecting = true;
      startCell = { x: parseInt(e.target.dataset.x), y: parseInt(e.target.dataset.y) };
      selectedCells = [startCell];
      updateSelection();
    }

    function handleMouseEnter(e) {
      if (!isSelecting) return;
      const x = parseInt(e.target.dataset.x);
      const y = parseInt(e.target.dataset.y);
      updateSelectionPath(x, y);
    }

    function handleMouseUp() {
      if (!isSelecting) return;
      isSelecting = false;
      checkSelection();
      clearSelection();
    }

    function handleTouchStart(e) {
      e.preventDefault();
      const touch = e.touches[0];
      const cell = document.elementFromPoint(touch.clientX, touch.clientY);
      if (cell && cell.classList.contains('grid-cell')) {
        isSelecting = true;
        startCell = { x: parseInt(cell.dataset.x), y: parseInt(cell.dataset.y) };
        selectedCells = [startCell];
        updateSelection();
      }
    }

    function handleTouchMove(e) {
      e.preventDefault();
      if (!isSelecting) return;
      const touch = e.touches[0];
      const cell = document.elementFromPoint(touch.clientX, touch.clientY);
      if (cell && cell.classList.contains('grid-cell')) {
        const x = parseInt(cell.dataset.x);
        const y = parseInt(cell.dataset.y);
        updateSelectionPath(x, y);
      }
    }

    function handleTouchEnd() {
      if (!isSelecting) return;
      isSelecting = false;
      checkSelection();
      clearSelection();
    }

    function updateSelectionPath(endX, endY) {
      const dx = Math.sign(endX - startCell.x);
      const dy = Math.sign(endY - startCell.y);
      
      // Only allow straight lines or 45-degree diagonals
      const distX = Math.abs(endX - startCell.x);
      const distY = Math.abs(endY - startCell.y);
      
      if (distX !== 0 && distY !== 0 && distX !== distY) return;
      
      selectedCells = [];
      const steps = Math.max(distX, distY);
      
      for (let i = 0; i <= steps; i++) {
        selectedCells.push({
          x: startCell.x + i * dx,
          y: startCell.y + i * dy
        });
      }
      
      updateSelection();
    }

    function updateSelection() {
      document.querySelectorAll('.grid-cell').forEach(cell => {
        cell.classList.remove('selected');
        if (!cell.classList.contains('found')) {
          cell.style.background = 'rgba(255,255,255,0.08)';
        }
      });

      selectedCells.forEach(pos => {
        const cell = document.querySelector(`[data-x="${pos.x}"][data-y="${pos.y}"]`);
        if (cell && !cell.classList.contains('found')) {
          cell.classList.add('selected');
          cell.style.background = 'rgba(233,69,96,0.5)';
        }
      });
    }

    function clearSelection() {
      document.querySelectorAll('.grid-cell.selected').forEach(cell => {
        cell.classList.remove('selected');
        if (!cell.classList.contains('found')) {
          cell.style.background = 'rgba(255,255,255,0.08)';
        }
      });
      selectedCells = [];
    }

    function checkSelection() {
      const selectedWord = selectedCells.map(pos => grid[pos.y][pos.x]).join('');
      const reversedWord = selectedWord.split('').reverse().join('');

      let foundWord = null;
      if (words.includes(selectedWord) && !foundWords.has(selectedWord)) {
        foundWord = selectedWord;
      } else if (words.includes(reversedWord) && !foundWords.has(reversedWord)) {
        foundWord = reversedWord;
      }

      if (foundWord) {
        foundWords.add(foundWord);
        
        selectedCells.forEach(pos => {
          const cell = document.querySelector(`[data-x="${pos.x}"][data-y="${pos.y}"]`);
          if (cell) {
            cell.classList.add('found');
            cell.style.background = '#e94560';
          }
        });

        const wordEl = document.querySelector(`[data-word="${foundWord}"]`);
        if (wordEl) {
          wordEl.classList.add('found');
        }

        updateProgress();
      }
    }
  </script>
 <script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9cc5d8aa11ce7a2d',t:'MTc3MDgzMzg4MC4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>